#!/usr/bin/env bash
set -u

#############################################
# KONFIGURATION
#############################################

BOOKMARKS=(
    "/home/$USER/Videos"
    "/mnt/storage/Filme"
    "MANUELL"
)

QUALITY_MAP_100=16
QUALITY_MAP_90=18
QUALITY_MAP_80=20

VAAPI_DEVICE="/dev/dri/renderD128"

#############################################
# QUICK-MODE ERKENNUNG
#############################################

QUICK_MODE=0
if [[ "${1:-}" == "-go" || "${1:-}" == "--go" ]]; then
    QUICK_MODE=1
    echo "=== QUICK MODE AKTIVIERT ==="
    echo "Verwende Standard-Einstellungen..."
    echo
fi

#############################################
# HILFSFUNKTIONEN FÃœR NAVIGATION
#############################################

nav_check() {
    (( QUICK_MODE == 1 )) && return
    local v="${1:-}"
    case "$v" in
        q|Q)
            echo "Abbruch durch Benutzer."
            exit 0
            ;;
        z|Z)
            echo "ZurÃ¼ck zum Start..."
            exec "$0"
            ;;
    esac
}

#############################################
# FUNKTIONEN
#############################################

progress_bar() {
    local sec="$1"
    local total="$2"
    local bar_size=40

    (( total < 1 )) && total=1
    (( sec < 0 )) && sec=0
    (( sec > total )) && sec=$total

    local percent=$(( 100 * sec / total ))
    local filled=$(( bar_size * sec / total ))
    local empty=$(( bar_size - filled ))

    # Farbiger Progress-Bar
    local bar_color
    if (( percent < 30 )); then
        bar_color="\033[1;31m"  # Rot
    elif (( percent < 70 )); then
        bar_color="\033[1;33m"  # Gelb
    else
        bar_color="\033[1;32m"  # GrÃ¼n
    fi
    
    local reset="\033[0m"
    
    printf "${bar_color}["
    printf "%0.sâ–ˆ" $(seq 1 "$filled")
    printf "${reset}\033[2m"
    printf "%0.sâ–‘" $(seq 1 "$empty")
    printf "${reset}${bar_color}]${reset} %3d%%" "$percent"
}

to_seconds() {
    local t="$1"
    IFS=: read -r h m s <<<"$t"
    s=${s%.*}
    [[ -z "$h" || -z "$m" || -z "$s" ]] && echo 0 && return
    echo $((10#$h * 3600 + 10#$m * 60 + 10#$s))
}

file_hash() {
    local file="$1"
    # Schneller Hash: nur DateigrÃ¶ÃŸe + Pfad + Ã„nderungszeit
    # Statt SHA256 Ã¼ber die ganze Datei (viel schneller!)
    local size mtime
    size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
    mtime=$(stat -c%Y "$file" 2>/dev/null || stat -f%m "$file" 2>/dev/null || echo 0)
    echo "${file}-${size}-${mtime}" | sha256sum | awk '{print $1}'
}

get_duration() {
    local file="$1"

    # 1) normale Dauer
    local d
    d=$(ffprobe -v error -show_entries format=duration \
         -of default=nk=1:nw=1 "$file" 2>/dev/null || echo "")
    d=${d%.*}

    if [[ -n "$d" && "$d" != "N/A" ]]; then
        echo "$d"
        return
    fi

    # 2) Fallback: Frames / FPS (z.B. bei DJI)
    local frames fps_raw fps
    frames=$(ffprobe -v error -select_streams v:0 \
        -count_frames -show_entries stream=nb_read_frames \
        -of default=nk=1:nw=1 "$file" 2>/dev/null || echo "")
    fps_raw=$(ffprobe -v error -select_streams v:0 \
        -show_entries stream=r_frame_rate \
        -of default=nk=1:nw=1 "$file" 2>/dev/null || echo "")

    if [[ -z "$frames" || -z "$fps_raw" ]]; then
        echo 1
        return
    fi

    # r_frame_rate ist z.B. 50/1
    if [[ "$fps_raw" == */* ]]; then
        local num=${fps_raw%/*}
        local den=${fps_raw#*/}
        (( den == 0 )) && den=1
        fps=$(( num / den ))
    else
        fps=$fps_raw
    fi

    (( fps < 1 )) && fps=1
    d=$(( frames / fps ))
    (( d < 1 )) && d=1
    echo "$d"
}

check_duplicates() {
    echo
    echo "PrÃ¼fe auf Duplikate..."
    
    declare -A HASH_MAP
    local duplicates=0
    
    for f in "${SELECTED[@]}"; do
        local h=$(file_hash "$f")
        if [[ -v "HASH_MAP[$h]" ]]; then
            echo "âš ï¸  Duplikat gefunden:"
            echo "    Original: ${HASH_MAP[$h]}"
            echo "    Duplikat: $f"
            ((duplicates++))
        else
            HASH_MAP[$h]="$f"
        fi
    done
    
    if (( duplicates > 0 )); then
        echo
        echo "$duplicates Duplikat(e) gefunden."
        read -rp "Duplikate aus Liste entfernen? (j/n) [j]: " rem_dup
        nav_check "$rem_dup"
        rem_dup=${rem_dup:-j}
        
        if [[ "$rem_dup" =~ ^[Jj]$ ]]; then
            local NEW_SELECTED=()
            declare -A SEEN
            for f in "${SELECTED[@]}"; do
                local h=$(file_hash "$f")
                if [[ ! -v "SEEN[$h]" ]]; then
                    NEW_SELECTED+=("$f")
                    SEEN[$h]=1
                fi
            done
            SELECTED=("${NEW_SELECTED[@]}")
            echo "âœ“ ${#SELECTED[@]} eindeutige Videos verbleiben"
        fi
    else
        echo "âœ“ Keine Duplikate gefunden"
    fi
}

show_live_stats() {
    local pid="$1"
    local basename="$2"
    
    while kill -0 "$pid" 2>/dev/null; do
        local cpu=$(ps -p "$pid" -o %cpu --no-headers 2>/dev/null | tr -d ' ' || echo "0")
        cpu=${cpu%.*}  # Nur ganze Zahl
        [[ -z "$cpu" ]] && cpu=0
        
        local gpu="--"
        local gpu_engine=""
        
        # GPU-Auslastung ermitteln (verschiedene Methoden)
        
        # 1. AMD: amdgpu_top (beste Option fÃ¼r moderne AMD GPUs)
        if command -v amdgpu_top &>/dev/null; then
            # amdgpu_top mit -J fÃ¼r JSON und -d fÃ¼r dump mode
            local gpu_data
            gpu_data=$(timeout 2 amdgpu_top -J -d 2>/dev/null | head -1 || echo "")
            
            if [[ -n "$gpu_data" ]]; then
                # Parse JSON fÃ¼r gpu_activity.GFX.value
                gpu=$(echo "$gpu_data" | grep -oP '"gpu_activity"[^}]*"GFX"[^}]*"value"\s*:\s*\K[0-9]+' | head -1 || echo "")
                [[ -n "$gpu" && "$gpu" != "0" ]] && gpu_engine="AMD"
            fi
        fi
        
        # 2. nvtop (universal, funktioniert mit AMD/NVIDIA/Intel)
        if [[ -z "$gpu" || "$gpu" == "0" ]] && command -v nvtop &>/dev/null; then
            # nvtop im Batch-Mode (1 Iteration)
            gpu=$(timeout 2 nvtop -b -d 1 2>/dev/null | grep -oP 'GPU\s+\|\s+\K[0-9]+(?=\s*%)' | head -1 || echo "")
            if [[ -z "$gpu" ]]; then
                # Alternative Parsing-Methode
                gpu=$(timeout 2 nvtop -b -d 1 2>/dev/null | grep -i "gpu" | grep -oP '\d+(?=%)' | head -1 || echo "")
            fi
            [[ -n "$gpu" && "$gpu" != "0" ]] && gpu_engine="GPU"
        fi
        
        # 3. AMD: sysfs Interface (Ã¤ltere Karten)
        if [[ -z "$gpu" || "$gpu" == "0" ]] && [[ -f /sys/class/drm/card0/device/gpu_busy_percent ]]; then
            gpu=$(cat /sys/class/drm/card0/device/gpu_busy_percent 2>/dev/null || echo "")
            [[ -n "$gpu" && "$gpu" != "0" ]] && gpu_engine="AMD"
        fi
        
        # 4. AMD: card1 (falls card0 nicht die GPU ist)
        if [[ -z "$gpu" || "$gpu" == "0" ]] && [[ -f /sys/class/drm/card1/device/gpu_busy_percent ]]; then
            gpu=$(cat /sys/class/drm/card1/device/gpu_busy_percent 2>/dev/null || echo "")
            [[ -n "$gpu" && "$gpu" != "0" ]] && gpu_engine="AMD"
        fi
        
        # 5. AMD: hwmon Interface
        if [[ -z "$gpu" || "$gpu" == "0" ]]; then
            for hwmon in /sys/class/drm/card*/device/hwmon/hwmon*/gpu_busy_percent; do
                if [[ -f "$hwmon" ]]; then
                    gpu=$(cat "$hwmon" 2>/dev/null || echo "")
                    if [[ -n "$gpu" && "$gpu" != "0" ]]; then
                        gpu_engine="AMD"
                        break
                    fi
                fi
            done
        fi
        
        # 6. Intel GPU (Fallback)
        if [[ -z "$gpu" || "$gpu" == "0" ]] && command -v intel_gpu_top &>/dev/null; then
            gpu=$(timeout 1 intel_gpu_top -l 1 2>/dev/null | grep -oP 'Render/3D:\s+\K[0-9]+' | head -1 || echo "")
            [[ -n "$gpu" ]] && gpu_engine="Intel"
        fi
        
        # Bereinige GPU-Wert
        [[ -z "$gpu" || "$gpu" == "0" ]] && gpu="--"
        
        local temp="--"
        local temp_unit="Â°C"
        
        # CPU-Temperatur ermitteln (verschiedene Quellen)
        if command -v sensors &>/dev/null; then
            temp=$(sensors 2>/dev/null | grep -oP '(Package id 0|Tctl):\s+\+\K[0-9]+' | head -1 || echo "")
        fi
        
        # Fallback: thermal_zone
        if [[ -z "$temp" || "$temp" == "0" ]]; then
            for zone in /sys/class/thermal/thermal_zone*/temp; do
                if [[ -f "$zone" ]]; then
                    local t=$(cat "$zone" 2>/dev/null || echo "0")
                    t=$((t / 1000))
                    if (( t > 20 && t < 120 )); then
                        temp=$t
                        break
                    fi
                fi
            done
        fi
        
        [[ -z "$temp" || "$temp" == "0" ]] && temp="--"
        
        # Farbige Anzeige mit Icons
        local cpu_color=""
        local gpu_color=""
        local temp_color=""
        
        # CPU Farbe
        if [[ "$cpu" != "--" ]]; then
            if (( cpu > 80 )); then
                cpu_color="\033[1;31m"  # Rot
            elif (( cpu > 50 )); then
                cpu_color="\033[1;33m"  # Gelb
            else
                cpu_color="\033[1;32m"  # GrÃ¼n
            fi
        fi
        
        # GPU Farbe
        if [[ "$gpu" != "--" ]]; then
            if (( gpu > 80 )); then
                gpu_color="\033[1;31m"
            elif (( gpu > 50 )); then
                gpu_color="\033[1;33m"
            else
                gpu_color="\033[1;32m"
            fi
        fi
        
        # Temp Farbe
        if [[ "$temp" != "--" ]]; then
            if (( temp > 80 )); then
                temp_color="\033[1;31m"
            elif (( temp > 65 )); then
                temp_color="\033[1;33m"
            else
                temp_color="\033[1;36m"  # Cyan
            fi
        fi
        
        local reset="\033[0m"
        
        # SchÃ¶ne Ausgabe mit Icons und Farben
        echo -ne "\r\033[K"  # Zeile lÃ¶schen
        echo -ne "âš™ï¸  ${cpu_color}CPU:${reset} ${cpu_color}${cpu}%${reset} â”‚ "
        echo -ne "ğŸ® ${gpu_color}GPU:${reset} ${gpu_color}${gpu}%${reset} â”‚ "
        echo -ne "ğŸŒ¡ï¸  ${temp_color}${temp}${temp_unit}${reset} â”‚ "
        echo -ne "\033[1;36m${basename}\033[0m"
        
        sleep 2
    done
    echo -ne "\r\033[K"  # Zeile lÃ¶schen am Ende
}

estimate_space() {
    local total_size=0
    for f in "${SELECTED[@]}"; do
        size=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo 0)
        total_size=$((total_size + size))
    done
    
    # Verschiedene SchÃ¤tzungen je nach Modus
    if [[ "$AUDIO_MODE" == "1" ]]; then
        # Nur Audio: sehr klein, ~5% der OriginalgrÃ¶ÃŸe
        echo $((total_size / 20))
    elif [[ "$TARGET_CODEC" == "h264" ]]; then
        # H.264: ~60-70% der OriginalgrÃ¶ÃŸe
        echo $((total_size * 7 / 10))
    else
        # DNxHR/ProRes: grÃ¶ÃŸer als Original
        echo $((total_size * 15 / 10))
    fi
}

check_disk_space() {
    local needed="$1"
    local target="$2"
    
    local avail
    avail=$(df --output=avail "$target" 2>/dev/null | tail -1 || df "$target" | tail -1 | awk '{print $4}')
    avail=$((avail * 1024))
    
    local needed_gb=$((needed / 1024 / 1024 / 1024))
    local avail_gb=$((avail / 1024 / 1024 / 1024))
    
    echo "GeschÃ¤tzter Platzbedarf: ~${needed_gb} GB"
    echo "VerfÃ¼gbarer Platz: ${avail_gb} GB"
    
    if (( needed > avail )); then
        echo "âš ï¸  WARNUNG: MÃ¶glicherweise nicht genug Speicherplatz!"
        if (( QUICK_MODE == 0 )); then
            read -rp "Trotzdem fortfahren? (j/n) [n]: " cont
            nav_check "$cont"
            if [[ ! "$cont" =~ ^[Jj]$ ]]; then
                echo "Abbruch."
                exit 0
            fi
        else
            echo "Quick-Mode: Fahre trotzdem fort..."
        fi
    fi
}

validate_output() {
    local input="$1"
    local output="$2"
    local input_dur="$3"
    
    if [[ ! -f "$output" ]]; then
        echo "FEHLER: Output-Datei nicht erstellt!"
        return 1
    fi
    
    # PrÃ¼fe ob Datei grÃ¶ÃŸer als 0 Bytes ist
    local out_size
    out_size=$(stat -c%s "$output" 2>/dev/null || stat -f%z "$output" 2>/dev/null || echo 0)
    if (( out_size < 1000 )); then
        echo "âš ï¸  FEHLER: Output-Datei zu klein (${out_size} Bytes)!"
        return 1
    fi
    
    local out_dur
    out_dur=$(get_duration "$output")
    
    # Bessere Fehlerbehandlung fÃ¼r kurze Videos
    if [[ -z "$out_dur" || "$out_dur" == "0" || "$out_dur" == "N/A" ]]; then
        echo "âš ï¸  WARNUNG: Konnte Output-Dauer nicht ermitteln (Input: ${input_dur}s)"
        echo "    PrÃ¼fe Datei manuell: $output"
        # Wenn die Datei existiert und groÃŸ genug ist, als Erfolg werten
        if (( out_size > 100000 )); then
            echo "    Datei scheint OK zu sein (${out_size} Bytes), setze fort..."
            return 0
        fi
        return 1
    fi
    
    local tolerance=$((input_dur / 50))
    (( tolerance < 5 )) && tolerance=5
    
    # FÃ¼r sehr kurze Videos (< 10s) groÃŸzÃ¼gigere Toleranz
    if (( input_dur < 10 )); then
        tolerance=2
    fi
    
    if (( out_dur < input_dur - tolerance )); then
        echo "âš ï¸  WARNUNG: Output scheint defekt (zu kurz: ${out_dur}s statt ${input_dur}s)!"
        echo "    Input:  $input"
        echo "    Output: $output"
        return 1
    fi
    
    return 0
}

show_eta() {
    local count="$1"
    local total="$2"
    local start_time="$3"
    
    if (( count < 3 )); then
        return
    fi
    
    local elapsed=$((SECONDS - start_time))
    local avg_per_file=$((elapsed / count))
    local remaining=$((total - count))
    local eta_sec=$((remaining * avg_per_file))
    
    local eta_min=$((eta_sec / 60))
    local eta_hour=$((eta_min / 60))
    local eta_min=$((eta_min % 60))
    
    echo -ne "${CYAN}â±ï¸  ${RESET}"
    if (( eta_hour > 0 )); then
        echo -e "GeschÃ¤tzte Restzeit: ${YELLOW}${eta_hour}h ${eta_min}min${RESET}"
    else
        echo -e "GeschÃ¤tzte Restzeit: ${YELLOW}${eta_min} Minuten${RESET}"
    fi
}

send_notification() {
    local title="$1"
    local message="$2"
    
    if command -v notify-send &>/dev/null; then
        notify-send "$title" "$message" 2>/dev/null || true
    fi
}

shutdown_with_countdown() {
    local action="$1"
    
    echo
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    if [[ "$action" == "poweroff" ]]; then
        echo "  System wird in 30 Sekunden heruntergefahren"
    else
        echo "  System wird in 30 Sekunden neu gestartet"
    fi
    echo "  DrÃ¼cke STRG+C zum Abbrechen"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo
    
    for i in {30..1}; do
        echo -ne "\rCountdown: $i Sekunden...  "
        sleep 1
    done
    echo
    
    systemctl "$action" -i
}

#############################################
# START
#############################################

START_TIME=$SECONDS

# Farbdefinitionen
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
MAGENTA='\033[1;35m'
CYAN='\033[1;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

if (( QUICK_MODE == 0 )); then
    clear
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${CYAN}â•‘${RESET}  ${BOLD}ğŸ¬ Video/Audio Transcoder v2.0${RESET}       ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo
    echo -e "${DIM}(Hinweis: 'q' = quit, 'z' = zurÃ¼ck zum Start)${RESET}"
    echo -e "${DIM}(Quick-Mode: Starte mit '-go' fÃ¼r sofortigen Start)${RESET}"
    echo
else
    clear
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${CYAN}â•‘${RESET}  ${BOLD}âš¡ QUICK MODE AKTIVIERT${RESET}                 ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo -e "${GREEN}âœ“${RESET} Verwende Standard-Einstellungen..."
    echo
fi

#############################################
# QUICK MODE: STANDARD-EINSTELLUNGEN
#############################################

if (( QUICK_MODE == 1 )); then
    # Standard-Einstellungen
    SRC="$PWD"
    REC="n"
    PRESERVE_STRUCTURE=0
    SEARCH_DIRS=("$SRC")
    AUDIO_MODE="3"  # Audio UND Video
    CONVERT_AUDIO=1
    CONVERT_VIDEO=1
    CODEC_SEL="2"  # DNxHR SQ
    TARGET_CODEC="dnxhr_sq"
    CODEC_NAME="DNxHR SQ"
    FILE_EXT="mov"
    RES="2"  # Max 1080p
    SCALE_FILTER="scale='min(1920,iw)':'min(1080,ih)':force_original_aspect_ratio=decrease"
    MODE=1  # CPU
    AUDIO_CODEC="pcm_s16le"
    PARALLEL=1
    DRY="n"
    NAM="2"  # _fixed Suffix
    EO="j"
    OUTROOT="$SRC/transcoded_${CODEC_NAME// /_}"
    DEL="n"
    POW="1"  # nichts
    
    if ! mkdir -p "$OUTROOT"; then
        echo "FEHLER: Kann Zielordner nicht erstellen: $OUTROOT"
        exit 1
    fi
    
    LOGFILE="$OUTROOT/transcoding.log"
    STATEFILE="$OUTROOT/.transcoding_state"
    
    echo -e "${CYAN}âœ“${RESET} Quelle: ${BOLD}$SRC${RESET}"
    echo -e "${CYAN}âœ“${RESET} Ziel: ${BOLD}$OUTROOT${RESET}"
    echo -e "${CYAN}âœ“${RESET} Modus: ${GREEN}Audio UND Video (DNxHR SQ + PCM)${RESET}"
    echo -e "${CYAN}âœ“${RESET} AuflÃ¶sung: ${GREEN}Max 1080p${RESET}"
    echo -e "${CYAN}âœ“${RESET} Encoder: ${GREEN}CPU${RESET}"
    echo
    
    # Springe direkt zur Dateisuche
    goto_file_search=1
else
    goto_file_search=0
fi

#############################################
# QUELLE WÃ„HLEN (nur im interaktiven Modus)
#############################################

if (( goto_file_search == 0 )); then
    echo "Quelle wÃ¤hlen (q=quit, z=zurÃ¼ck):"
    echo "0) aktueller Ordner ($PWD)"
    i=1
    for bm in "${BOOKMARKS[@]}"; do
        echo "$i) $bm"
        ((i++))
    done

    read -e -p "Auswahl [0]: " sel
    nav_check "$sel"
    sel=${sel:-0}

    if [[ "$sel" == /* || -d "$sel" ]]; then
        SRC="$sel"
    elif [[ "$sel" == "0" ]]; then
        SRC="$PWD"
    else
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            echo "UngÃ¼ltige Auswahl."
            exit 1
        fi
        if (( sel < 1 || sel > ${#BOOKMARKS[@]} )); then
            echo "UngÃ¼ltige Auswahl."
            exit 1
        fi
        if [[ "${BOOKMARKS[$((sel-1))]}" == "MANUELL" ]]; then
            read -e -p "Pfad eingeben (q=quit, z=zurÃ¼ck): " SRC
            nav_check "$SRC"
        else
            SRC="${BOOKMARKS[$((sel-1))]}"
        fi
    fi

    if [[ ! -d "$SRC" ]]; then
        echo "Ordner existiert nicht: $SRC"
        exit 1
    fi

    #############################################
    # REKURSION / ORDNER-AUSWAHL
    #############################################

    read -rp "Unterordner einbeziehen? (j/n/q/z) [n]: " REC
    nav_check "$REC"
    REC=${REC:-n}

    PRESERVE_STRUCTURE=0
    SEARCH_DIRS=()

    if [[ "$REC" =~ ^[Jj]$ ]]; then
        mapfile -t SUBDIRS < <(find "$SRC" -type d | sort)

        echo
        echo "Unterordner (q=quit, z=zurÃ¼ck):"
        idx=1
        for d in "${SUBDIRS[@]}"; do
            rel="${d#$SRC}"
            [[ -z "$rel" ]] && rel="/"
            echo "$idx) $rel"
            ((idx++))
        done
        echo

        read -e -p "Welche Ordner durchsuchen? (z.B. 1 3 5-7 oder 'alle') [alle]: " DLIST
        nav_check "$DLIST"
        DLIST=${DLIST:-alle}

        if [[ "$DLIST" =~ ^([Aa]ll|[Aa]lle)$ ]]; then
            SEARCH_DIRS=("${SUBDIRS[@]}")
        else
            for part in $DLIST; do
                if [[ "$part" =~ ^[0-9]+-[0-9]+$ ]]; then
                    start=${part%-*}
                    end=${part#*-}
                    for ((x=start; x<=end; x++)); do
                        (( x >= 1 && x <= ${#SUBDIRS[@]} )) && SEARCH_DIRS+=("${SUBDIRS[$((x-1))]}")
                    done
                elif [[ "$part" =~ ^[0-9]+$ ]]; then
                    (( part >= 1 && part <= ${#SUBDIRS[@]} )) && SEARCH_DIRS+=("${SUBDIRS[$((part-1))]}")
                fi
            done
        fi

        if (( ${#SEARCH_DIRS[@]} == 0 )); then
            echo "Keine gÃ¼ltigen Ordner ausgewÃ¤hlt."
            exit 0
        fi

        echo
        echo "Ordnerstruktur im Ziel erhalten? (q=quit, z=zurÃ¼ck)"
        echo "1) Alles in EINEM Zielordner"
        echo "2) Ordnerstruktur beibehalten (Unterordner spiegeln)"
        read -rp "Auswahl [1]: " FSTRUCT
        nav_check "$FSTRUCT"
        FSTRUCT=${FSTRUCT:-1}
        if [[ "$FSTRUCT" == "2" ]]; then
            PRESERVE_STRUCTURE=1
        else
            PRESERVE_STRUCTURE=0
        fi
    else
        SEARCH_DIRS=("$SRC")
        PRESERVE_STRUCTURE=0
    fi

    #############################################
    # NEU: AUDIO/VIDEO MODUS
    #############################################

    echo
    echo "Was soll konvertiert werden? (q=quit, z=zurÃ¼ck):"
    echo "1) Nur Audio (AAC â†’ PCM fÃ¼r DaVinci Resolve)"
    echo "2) Nur Video (Codec Ã¤ndern, Audio kopieren)"
    echo "3) Audio UND Video (beides konvertieren)"
    read -rp "Auswahl [3]: " AUDIO_MODE
    nav_check "$AUDIO_MODE"
    AUDIO_MODE=${AUDIO_MODE:-3}

    case "$AUDIO_MODE" in
        1) 
            echo "âœ“ Nur Audio wird konvertiert (Video bleibt Original)"
            CONVERT_AUDIO=1
            CONVERT_VIDEO=0
            ;;
        2) 
            echo "âœ“ Nur Video wird konvertiert (Audio bleibt Original)"
            CONVERT_AUDIO=0
            CONVERT_VIDEO=1
            ;;
        3) 
            echo "âœ“ Audio UND Video werden konvertiert"
            CONVERT_AUDIO=1
            CONVERT_VIDEO=1
            ;;
        *) 
            CONVERT_AUDIO=1
            CONVERT_VIDEO=1
            ;;
    esac

    #############################################
    # VIDEO-CODEC (nur wenn Video konvertiert wird)
    #############################################

    if (( CONVERT_VIDEO == 1 )); then
        echo
        echo "Ziel-Codec (q=quit, z=zurÃ¼ck):"
        echo "1) H.264 (klein, Archiv/YouTube)"
        echo "2) DNxHR SQ (Videoschnitt, DaVinci) - empfohlen!"
        echo "3) DNxHR HQ (hÃ¶chste QualitÃ¤t, Videoschnitt)"
        echo "4) ProRes 422 (Apple-Standard, Videoschnitt)"
        read -rp "Auswahl [2]: " CODEC_SEL
        nav_check "$CODEC_SEL"
        CODEC_SEL=${CODEC_SEL:-2}

        case "$CODEC_SEL" in
            1) 
                TARGET_CODEC="h264"
                CODEC_NAME="H.264"
                FILE_EXT="mp4"
                ;;
            2) 
                TARGET_CODEC="dnxhr_sq"
                CODEC_NAME="DNxHR SQ"
                FILE_EXT="mov"
                ;;
            3) 
                TARGET_CODEC="dnxhr_hq"
                CODEC_NAME="DNxHR HQ"
                FILE_EXT="mov"
                ;;
            4) 
                TARGET_CODEC="prores"
                CODEC_NAME="ProRes 422"
                FILE_EXT="mov"
                ;;
            *) 
                TARGET_CODEC="dnxhr_sq"
                CODEC_NAME="DNxHR SQ"
                FILE_EXT="mov"
                ;;
        esac

        echo "GewÃ¤hlt: $CODEC_NAME"
        echo

        if [[ "$TARGET_CODEC" == "h264" ]]; then
            echo "QualitÃ¤t (visuell) (q=quit, z=zurÃ¼ck):"
            echo "1) 100%  (CRF $QUALITY_MAP_100)"
            echo "2)  90%  (CRF $QUALITY_MAP_90)"
            echo "3)  80%  (CRF $QUALITY_MAP_80)"
            read -rp "Auswahl [2]: " Q
            nav_check "$Q"
            Q=${Q:-2}

            case "$Q" in
                1) CRF=$QUALITY_MAP_100 ;;
                2) CRF=$QUALITY_MAP_90 ;;
                3) CRF=$QUALITY_MAP_80 ;;
                *) CRF=$QUALITY_MAP_90 ;;
            esac
        fi

        echo "AuflÃ¶sung (q=quit, z=zurÃ¼ck):"
        echo "1) Original beibehalten"
        echo "2) Max 1080p (4K â†’ 1080p downscale)"
        echo "3) Max 720p"
        read -rp "Auswahl [2]: " RES
        nav_check "$RES"
        RES=${RES:-2}

        case "$RES" in
            1) SCALE_FILTER="" ;;
            2) SCALE_FILTER="scale='min(1920,iw)':'min(1080,ih)':force_original_aspect_ratio=decrease" ;;
            3) SCALE_FILTER="scale='min(1280,iw)':'min(720,ih)':force_original_aspect_ratio=decrease" ;;
            *) SCALE_FILTER="scale='min(1920,iw)':'min(1080,ih)':force_original_aspect_ratio=decrease" ;;
        esac

        echo "Modus (q=quit, z=zurÃ¼ck):"
        if [[ "$TARGET_CODEC" == "h264" ]]; then
            echo "1) CPU (libx264)"
            echo "2) GPU (VAAPI)"
            read -rp "Auswahl [2]: " MODE
            nav_check "$MODE"
            MODE=${MODE:-2}

            if [[ "$MODE" == "2" && ! -e "$VAAPI_DEVICE" ]]; then
                echo "âš ï¸  FEHLER: VAAPI-Device nicht gefunden: $VAAPI_DEVICE"
                echo "Fallback auf CPU-Modus..."
                MODE=1
            fi
        else
            MODE=1
        fi
    else
        # Nur Audio: setze Defaults
        FILE_EXT="mov"
        SCALE_FILTER=""
        MODE=1
    fi

    #############################################
    # AUDIO-CODEC (immer PCM fÃ¼r Resolve)
    #############################################

    if (( CONVERT_AUDIO == 1 )); then
        AUDIO_CODEC="pcm_s16le"
        echo "âœ“ Audio wird zu PCM konvertiert (unkomprimiert, fÃ¼r DaVinci Resolve)"
    else
        AUDIO_CODEC="copy"
    fi

    echo "Wie viele Dateien gleichzeitig verarbeiten? (q=quit, z=zurÃ¼ck)"
    echo "1) 1 (nacheinander, mit Fortschrittsbalken)"
    echo "2) 2 (parallel)"
    echo "3) 3 (parallel)"
    read -rp "Auswahl [1]: " PAR
    nav_check "$PAR"
    PAR=${PAR:-1}
    case "$PAR" in
        1|2|3) PARALLEL="$PAR" ;;
        *) PARALLEL=1 ;;
    esac

    read -rp "Dry-Run? nur anzeigen? (j/n/q/z) [n]: " DRY
    nav_check "$DRY"
    DRY=${DRY:-n}

    echo "Namensschema (q=quit, z=zurÃ¼ck):"
    echo "1) Original ersetzen"
    echo "2) _fixed Suffix"
    echo "3) gleicher Name im Zielordner"
    read -rp "Auswahl [2]: " NAM
    nav_check "$NAM"
    NAM=${NAM:-2}

    read -rp "Extra Ordner 'transcoded'? (j/n/q/z) [j]: " EO
    nav_check "$EO"
    EO=${EO:-j}
    if [[ "$EO" =~ ^[Jj]$ ]]; then
        if (( CONVERT_VIDEO == 1 )); then
            OUTROOT="$SRC/transcoded_${CODEC_NAME// /_}"
        else
            OUTROOT="$SRC/transcoded_audio_fixed"
        fi
    else
        OUTROOT="$SRC"
    fi

    if ! mkdir -p "$OUTROOT"; then
        echo "FEHLER: Kann Zielordner nicht erstellen: $OUTROOT"
        exit 1
    fi

    LOGFILE="$OUTROOT/transcoding.log"
    STATEFILE="$OUTROOT/.transcoding_state"

    read -rp "Originale lÃ¶schen? (j/n/q/z) [n]: " DEL
    nav_check "$DEL"
    DEL=${DEL:-n}

    echo "Aktion nach Fertig (q=quit, z=zurÃ¼ck):"
    echo "1) nichts"
    echo "2) shutdown"
    echo "3) reboot"
    read -rp "Auswahl [1]: " POW
    nav_check "$POW"
    POW=${POW:-1}
fi

#############################################
# DATEIEN FINDEN
#############################################

FILES=()

if [[ "$REC" =~ ^[Jj]$ ]]; then
    for d in "${SEARCH_DIRS[@]}"; do
        mapfile -t found < <(find "$d" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.mov" \))
        FILES+=("${found[@]}")
    done
else
    mapfile -t FILES < <(find "$SRC" -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.mov" \))
fi

if (( ${#FILES[@]} == 0 )); then
    echo "Keine Videos gefunden."
    exit 0
fi

if (( QUICK_MODE == 0 )); then
    echo
    echo "Gefundene Videos (q=quit, z=zurÃ¼ck):"
    i=1
    for f in "${FILES[@]}"; do
        echo "$i) $(basename "$f")"
        ((i++))
    done
    echo

    read -e -p "Welche? (z.B. 1 3 5-7 oder 'alle') [alle]: " LIST
    nav_check "$LIST"
    LIST=${LIST:-alle}

    SELECTED=()

    if [[ "$LIST" =~ ^([Aa]ll|[Aa]lle)$ ]]; then
        SELECTED=("${FILES[@]}")
    else
        for part in $LIST; do
            if [[ "$part" =~ ^[0-9]+-[0-9]+$ ]]; then
                start=${part%-*}
                end=${part#*-}
                for ((x=start; x<=end; x++)); do
                    (( x >= 1 && x <= ${#FILES[@]} )) && SELECTED+=("${FILES[$((x-1))]}")
                done
            elif [[ "$part" =~ ^[0-9]+$ ]]; then
                (( part >= 1 && part <= ${#FILES[@]} )) && SELECTED+=("${FILES[$((part-1))]}")
            fi
        done
    fi
else
    # Quick-Mode: alle Dateien
    SELECTED=("${FILES[@]}")
    echo "Gefundene Videos: ${#SELECTED[@]}"
fi

if (( ${#SELECTED[@]} == 0 )); then
    echo "Keine gÃ¼ltige Datei ausgewÃ¤hlt."
    exit 0
fi

# DuplikatsprÃ¼fung nur im interaktiven Modus
if (( QUICK_MODE == 0 )); then
    read -rp "Auf Duplikate prÃ¼fen? (j/n) [n]: " check_dup
    nav_check "$check_dup"
    check_dup=${check_dup:-n}
    if [[ "$check_dup" =~ ^[Jj]$ ]]; then
        check_duplicates
    fi
fi

echo
needed=$(estimate_space)
check_disk_space "$needed" "$OUTROOT"

TOTAL=${#SELECTED[@]}
COUNT=0
SUCCESS_COUNT=0
FAILED_COUNT=0

#############################################
# HILFSFUNKTIONEN
#############################################

compute_dest_dir() {
    local src_file="$1"
    local dir dest rel

    dir=$(dirname "$src_file")

    if (( PRESERVE_STRUCTURE == 1 )); then
        rel="${dir#$SRC}"
        rel="${rel#/}"
        if [[ -z "$rel" ]]; then
            dest="$OUTROOT"
        else
            dest="$OUTROOT/$rel"
        fi
        if ! mkdir -p "$dest"; then
            echo "FEHLER: Kann Ordner nicht erstellen: $dest" >&2
            return 1
        fi
    else
        dest="$OUTROOT"
    fi

    echo "$dest"
}

transcode_file() {
    local F="$1"
    local INDEX="$2"
    local TOTAL="$3"
    local SHOW_PROGRESS="${4:-0}"

    local BASENAME
    BASENAME=$(basename "$F")

    local FHASH
    FHASH=$(file_hash "$F" 1)  # Schneller Hash zum Skippen
    if grep -q "^SUCCESS:$FHASH$" "$STATEFILE" 2>/dev/null; then
        echo -e "${DIM}[$INDEX/$TOTAL]${RESET} ${GREEN}âœ“${RESET} Bereits verarbeitet â†’ ${DIM}Skip: $BASENAME${RESET}"
        return 0
    fi
    local DUR
    DUR=$(get_duration "$F")
    [[ -z "$DUR" || "$DUR" -lt 1 ]] && DUR=1

    local DEST_DIR
    DEST_DIR=$(compute_dest_dir "$F")
    if [[ -z "$DEST_DIR" ]]; then
        echo "[$INDEX/$TOTAL] FEHLER: Zielordner-Problem bei $BASENAME" | tee -a "$LOGFILE"
        return 1
    fi

    local OUT
    case "$NAM" in
        1) OUT="$DEST_DIR/${BASENAME%.*}.$FILE_EXT" ;;
        2) OUT="$DEST_DIR/${BASENAME%.*}_fixed.$FILE_EXT" ;;
        3) OUT="$DEST_DIR/${BASENAME%.*}.$FILE_EXT" ;;
        *) OUT="$DEST_DIR/${BASENAME%.*}_fixed.$FILE_EXT" ;;
    esac

    if [[ -f "$OUT" ]]; then
        local H1 H2
        H1=$(file_hash "$F" 1)  # Schneller Hash
        H2=$(file_hash "$OUT" 1 || true)  # Schneller Hash
        if [[ "$H1" == "$H2" ]]; then
            echo "[$INDEX/$TOTAL] Hash identisch â†’ Skip: $BASENAME"
            echo "SUCCESS:$FHASH" >> "$STATEFILE"
            return 0
        fi
    fi

    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BOLD}â•‘${RESET} ${CYAN}â–¶${RESET}  Video ${BOLD}$INDEX${RESET}/${TOTAL}: ${BOLD}$(basename "$F")${RESET}"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

    if [[ "$DRY" =~ ^[Jj]$ ]]; then
        echo "Dry-Run: wÃ¼rde transcodieren â†’ $OUT"
        return 0
    fi

    local CMD=()
    
    # Video-Teil
    if (( CONVERT_VIDEO == 1 )); then
        if [[ "$TARGET_CODEC" == "h264" ]]; then
            if [[ "$MODE" == "2" ]]; then
                local vf_chain="format=nv12,hwupload"
                if [[ -n "$SCALE_FILTER" ]]; then
                    vf_chain="$SCALE_FILTER,format=nv12,hwupload"
                fi
                CMD=(ffmpeg -y -hwaccel vaapi -vaapi_device "$VAAPI_DEVICE" -i "$F" \
                      -vf "$vf_chain" \
                      -c:v h264_vaapi -qp "$CRF" \
                      -c:a "$AUDIO_CODEC" \
                      "$OUT")
            else
                if [[ -n "$SCALE_FILTER" ]]; then
                    CMD=(ffmpeg -y -i "$F" \
                          -vf "$SCALE_FILTER" \
                          -c:v libx264 -preset slow -crf "$CRF" \
                          -c:a "$AUDIO_CODEC" \
                          "$OUT")
                else
                    CMD=(ffmpeg -y -i "$F" \
                          -c:v libx264 -preset slow -crf "$CRF" \
                          -c:a "$AUDIO_CODEC" \
                          "$OUT")
                fi
            fi
        elif [[ "$TARGET_CODEC" == "dnxhr_sq" || "$TARGET_CODEC" == "dnxhr_hq" ]]; then
            # DNxHR benÃ¶tigt yuv422p Pixelformat
            if [[ -n "$SCALE_FILTER" ]]; then
                CMD=(ffmpeg -y -i "$F" \
                      -vf "$SCALE_FILTER,format=yuv422p" \
                      -c:v dnxhd -profile:v "$TARGET_CODEC" \
                      -c:a "$AUDIO_CODEC" \
                      "$OUT")
            else
                CMD=(ffmpeg -y -i "$F" \
                      -vf "format=yuv422p" \
                      -c:v dnxhd -profile:v "$TARGET_CODEC" \
                      -c:a "$AUDIO_CODEC" \
                      "$OUT")
            fi
        elif [[ "$TARGET_CODEC" == "prores" ]]; then
            # ProRes benÃ¶tigt yuv422p10le Pixelformat
            if [[ -n "$SCALE_FILTER" ]]; then
                CMD=(ffmpeg -y -i "$F" \
                      -vf "$SCALE_FILTER,format=yuv422p10le" \
                      -c:v prores_ks -profile:v 2 \
                      -c:a "$AUDIO_CODEC" \
                      "$OUT")
            else
                CMD=(ffmpeg -y -i "$F" \
                      -vf "format=yuv422p10le" \
                      -c:v prores_ks -profile:v 2 \
                      -c:a "$AUDIO_CODEC" \
                      "$OUT")
            fi
        fi
    else
        # Nur Audio konvertieren, Video kopieren
        CMD=(ffmpeg -y -i "$F" \
              -c:v copy \
              -c:a "$AUDIO_CODEC" \
              "$OUT")
    fi

    if (( SHOW_PROGRESS == 1 )); then
        echo  # Neue Zeile vor Progress
        
        # TemporÃ¤re Datei fÃ¼r ffmpeg Progress
        local PROGRESS_FILE="/tmp/ffmpeg_progress_$.txt"
        rm -f "$PROGRESS_FILE"
        
        # Mit Fortschrittsbalken - ffmpeg mit -progress
        CUR_FPS=""
        FIRST_PROGRESS=1
        "${CMD[@]}" -progress pipe:2 2>&1 | while IFS= read -r line; do
            # Parse FPS (muss vor out_time_ms kommen)
            if [[ "$line" =~ fps=([0-9.,]+) ]]; then
                CUR_FPS="${BASH_REMATCH[1]}"
                CUR_FPS="${CUR_FPS//,/.}"
            fi

            # Parse ffmpeg output
            if [[ "$line" =~ out_time_ms=([0-9]+) ]]; then
                # Zeit in Mikrosekunden
                SEC=$(( ${BASH_REMATCH[1]} / 1000000 ))
                [[ -z "$SEC" ]] && SEC=0
                ((SEC > DUR)) && SEC=$DUR

                # Zeit berechnen
                min_done=$((SEC / 60))
                sec_done=$((SEC % 60))
                min_total=$((DUR / 60))
                sec_total=$((DUR % 60))

                # ALLES in EINER Zeile ausgeben
                # Wenn nicht das erste Mal: gehe eine Zeile hoch
                if (( FIRST_PROGRESS == 0 )); then
                    printf "\033[A"
                fi

                printf "\r\033[K${CYAN}Fortschritt:${RESET} "
                progress_bar "$SEC" "$DUR"
                printf " ${DIM}|${RESET} ${CYAN}%02d:%02d${RESET}/${DIM}%02d:%02d${RESET}" "$min_done" "$sec_done" "$min_total" "$sec_total"

                # FPS nur wenn vorhanden
                if [[ -n "$CUR_FPS" ]]; then
                    printf " ${DIM}|${RESET} ${YELLOW}%.0f fps${RESET}" "$CUR_FPS" 2>/dev/null || true
                fi

                # Newline am Ende, damit Stats in der nÃ¤chsten Zeile erscheinen
                printf "\n"
                FIRST_PROGRESS=0
            fi

            # Speichere letzte Zeile fÃ¼r Exit-Code Check
            echo "$line" > "$PROGRESS_FILE"
        done &
        
        FFMPEG_PID=$!

        # System Stats in separate Zeile (direkt darunter, kein extra echo nÃ¶tig)
        show_live_stats "$FFMPEG_PID" "$BASENAME" &
        STATS_PID=$!
        
        wait "$FFMPEG_PID"
        FFMPEG_EXIT=$?
        
        kill "$STATS_PID" 2>/dev/null || true
        wait "$STATS_PID" 2>/dev/null || true
        
        rm -f "$PROGRESS_FILE"
        
        echo
        echo
    else
        # Ohne Fortschrittsbalken (parallel)
        if "${CMD[@]}" 2>&1 | tee -a "$LOGFILE" >/dev/null; then
            FFMPEG_EXIT=0
        else
            FFMPEG_EXIT=1
        fi
    fi

    if (( FFMPEG_EXIT == 0 )) && validate_output "$F" "$OUT" "$DUR"; then
        echo -e "${GREEN}âœ“${RESET} Erfolgreich abgeschlossen" | tee -a "$LOGFILE"
        echo "SUCCESS:$FHASH" >> "$STATEFILE"
        
        if [[ "$DEL" =~ ^[Jj]$ ]]; then
            rm -f "$F"
        fi
        return 0
    else
        echo -e "${RED}âš ${RESET} Validierung fehlgeschlagen!" | tee -a "$LOGFILE"
        echo "  Input:  $F (${DUR}s)" | tee -a "$LOGFILE"
        echo "  Output: $OUT" | tee -a "$LOGFILE"
        echo "  ffmpeg Exit-Code: $FFMPEG_EXIT" | tee -a "$LOGFILE"
        
        # PrÃ¼fe ob Output existiert
        if [[ -f "$OUT" ]]; then
            local out_size out_dur
            out_size=$(stat -c%s "$OUT" 2>/dev/null || stat -f%z "$OUT" 2>/dev/null || echo 0)
            out_dur=$(get_duration "$OUT" 2>/dev/null || echo "N/A")
            echo "  Output-GrÃ¶ÃŸe: $((out_size / 1024 / 1024)) MB, Dauer: ${out_dur}s" | tee -a "$LOGFILE"
        else
            echo "  Output-Datei existiert nicht!" | tee -a "$LOGFILE"
        fi
        
        echo "FAILED:$FHASH" >> "$STATEFILE"
        return 1
    fi
}

#############################################
# VERARBEITUNG
#############################################

echo
echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
echo -e "${CYAN}â•‘${RESET}  ${BOLD}â–¶  Starte Verarbeitung${RESET}                 ${CYAN}â•‘${RESET}"
echo -e "${CYAN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
if (( CONVERT_AUDIO == 1 && CONVERT_VIDEO == 0 )); then
    echo -e "${CYAN}â•‘${RESET}  Videos: ${YELLOW}${TOTAL}${RESET}                              ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•‘${RESET}  Modus:  ${GREEN}Nur Audio (AAC â†’ PCM)${RESET}          ${CYAN}â•‘${RESET}"
elif (( CONVERT_AUDIO == 0 && CONVERT_VIDEO == 1 )); then
    echo -e "${CYAN}â•‘${RESET}  Videos: ${YELLOW}${TOTAL}${RESET}                              ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•‘${RESET}  Modus:  ${GREEN}Nur Video ($CODEC_NAME)${RESET}       ${CYAN}â•‘${RESET}"
else
    echo -e "${CYAN}â•‘${RESET}  Videos: ${YELLOW}${TOTAL}${RESET}                              ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•‘${RESET}  Modus:  ${GREEN}Audio UND Video${RESET}                 ${CYAN}â•‘${RESET}"
    echo -e "${CYAN}â•‘${RESET}          ${GREEN}($CODEC_NAME + PCM)${RESET}            ${CYAN}â•‘${RESET}"
fi
echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo

if (( PARALLEL == 1 )); then
    for F in "${SELECTED[@]}"; do
        ((COUNT++))
        
        # Zeige Overall-Progress
        echo
        echo -ne "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}\n"
        echo -ne "${CYAN}â•‘${RESET} Gesamt-Fortschritt: ${BOLD}${COUNT}${RESET}/${TOTAL} Videos          ${CYAN}â•‘${RESET}\n"
        
        # Overall Progress-Bar
        overall_percent=$(( 100 * (COUNT - 1) / TOTAL ))
        overall_filled=$(( 30 * (COUNT - 1) / TOTAL ))
        overall_empty=$(( 30 - overall_filled ))
        
        echo -ne "${CYAN}â•‘${RESET} "
        if (( overall_percent < 30 )); then
            echo -ne "\033[1;31m"  # Rot
        elif (( overall_percent < 70 )); then
            echo -ne "\033[1;33m"  # Gelb
        else
            echo -ne "\033[1;32m"  # GrÃ¼n
        fi
        printf "%0.sâ–ˆ" $(seq 1 "$overall_filled")
        echo -ne "${RESET}\033[2m"
        printf "%0.sâ–‘" $(seq 1 "$overall_empty")
        printf "${RESET} %3d%%  ${CYAN}â•‘${RESET}\n" "$overall_percent"
        echo -ne "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
        
        if (( COUNT >= 3 )); then
            show_eta "$SUCCESS_COUNT" "$TOTAL" "$START_TIME"
        fi
        
        echo
        
        if transcode_file "$F" "$COUNT" "$TOTAL" 1; then
            ((SUCCESS_COUNT++))
        else
            ((FAILED_COUNT++))
        fi
    done
else
    JOBS=0
    INDEX=0
    for F in "${SELECTED[@]}"; do
        ((INDEX++))
        transcode_file "$F" "$INDEX" "$TOTAL" 0 &
        ((JOBS++))
        if ((JOBS >= PARALLEL)); then
            wait -n || true
            ((JOBS--))
        fi
    done
    wait || true
    
    # ZÃ¤hle Erfolge aus Statefile
    SUCCESS_COUNT=$(grep -c "^SUCCESS:" "$STATEFILE" 2>/dev/null || echo 0)
    FAILED_COUNT=$((TOTAL - SUCCESS_COUNT))
fi

#############################################
# ENDE
#############################################

echo
echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
echo -e "${CYAN}â•‘${RESET}  ${BOLD}âœ“ Transkodierung abgeschlossen!${RESET}        ${CYAN}â•‘${RESET}"
echo -e "${CYAN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
echo -e "${CYAN}â•‘${RESET}  ${GREEN}Erfolgreich:${RESET}    ${BOLD}${SUCCESS_COUNT}${RESET} / ${TOTAL}              ${CYAN}â•‘${RESET}"
if (( FAILED_COUNT > 0 )); then
    echo -e "${CYAN}â•‘${RESET}  ${RED}Fehlgeschlagen:${RESET} ${BOLD}${FAILED_COUNT}${RESET}                    ${CYAN}â•‘${RESET}"
fi
echo -e "${CYAN}â•‘${RESET}                                            ${CYAN}â•‘${RESET}"
echo -e "${CYAN}â•‘${RESET}  ${DIM}Logfile: transcoding.log${RESET}            ${CYAN}â•‘${RESET}"
echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo

send_notification "Transcoding abgeschlossen" "$SUCCESS_COUNT von $TOTAL Videos erfolgreich verarbeitet"

case "$POW" in
    2) shutdown_with_countdown "poweroff" ;;
    3) shutdown_with_countdown "reboot" ;;
esac

echo "Fertig!"